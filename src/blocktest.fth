\ To test the ANS Forth Block word set and extension words

\ This program was written by Steve Palmer in 2015, with contributions from
\ others where indicated, and is in the public domain - it can be distributed
\ and/or modified in any way but please retain this notice.

\ This program is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

\ The tests are not claimed to be comprehensive or correct

\ ------------------------------------------------------------------------------
\ Version 0.1 23 October 2015  First Version

\ ------------------------------------------------------------------------------
\ The tests are based on John Hayes test program for the core word set
\
\ Words tested in this file are:
\     BLK BLOCK BUFFER EVALUATE FLUSH LOAD SAVE-BUFFERS UPDATE
\     EMPTY-BUFFERS LIST SCR THRU \
\
\ ------------------------------------------------------------------------------
\ Assumptions and dependencies:
\     - tester.fr or ttester.fs has been loaded prior to this file
\     - errorreport.fth has been loaded prior to this file
\     - utils.fth has been loaded prior to this file
\ ------------------------------------------------------------------------------
TESTING Block word set

DECIMAL

[DEFINED] MARKER [IF] MARKER BLOCK-TEST-DICTIONARY [THEN]

\ Define these constants from the system documentation provided
20 CONSTANT FIRST-TEST-BLOCK
26 CONSTANT LIMIT-TEST-BLOCK \ one beyond the last

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< 0= [IF]
    .( Warning: Test Block range not identified ) CR
    .( Only superficial testing of Block word set will be possible ) CR
[THEN]

\ Derived constants and functions
LIMIT-TEST-BLOCK FIRST-TEST-BLOCK - CONSTANT TEST-BLOCK-COUNT

PRNG BLOCK-PRNG
\ Generated by Random.org
BLOCK-PRNG -1865266521 188896058 -2021545234 -1456609962 PRNG-SET-SEED
: BLOCK-RND ( -- rnd )                BLOCK-PRNG PRNG-RND ;
: BLOCK-RANDOM ( lower upper -- rnd ) BLOCK-PRNG PRNG-RANDOM ;

: RND-TEST-BLOCK ( -- blk )
    FIRST-TEST-BLOCK LIMIT-TEST-BLOCK BLOCK-RANDOM ;

\ Two distinct random test blocks
: 2RND-TEST-BLOCKS ( -- blk1 blk2 )
    RND-TEST-BLOCK BEGIN  \ blk1
        RND-TEST-BLOCK    \ blk1 blk2
        2DUP =            \ blk1 blk2 blk1==blk2
    WHILE                 \ blk1 blk1
        DROP              \ blk1
    REPEAT ;              \ blk1 blk2

\ first random test block in a sequence of length u
: RND-TEST-BLOCK-SEQ ( u -- blk )
    FIRST-TEST-BLOCK LIMIT-TEST-BLOCK ROT 1- - BLOCK-RANDOM ;

\ ------------------------------------------------------------------------------
TESTING BLOCK ( read-only mode )

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    \ BLOCK signature
    T{ RND-TEST-BLOCK BLOCK DUP ALIGNED = -> TRUE }T

    \ BLOCK accepts all blocks in the test range
    : BLOCK-ALL ( -- )
        LIMIT-TEST-BLOCK FIRST-TEST-BLOCK DO
            I BLOCK DROP
        LOOP
    ;
    T{ BLOCK-ALL -> }T

    \ BLOCK twice on same block returns the same value
    T{ RND-TEST-BLOCK DUP BLOCK SWAP BLOCK = -> TRUE }T

    \ BLOCK twice on distinct block numbers
    \ may or may not return the same value!
    \ Nothing to test
[THEN]

\ ------------------------------------------------------------------------------
TESTING BUFFER ( read-only mode )

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    \ Although it is not in the spirit of the specification,
    \ a compliant definition of BUFFER would be
    \ : BUFFER BLOCK ;
    \ So we can only repeat the tests for BLOCK ...

    \ BUFFER signature
    T{ RND-TEST-BLOCK BUFFER DUP ALIGNED = -> TRUE }T

    \ BUFFER accepts all blocks in the test range
    : BUFFER-ALL ( -- )
        LIMIT-TEST-BLOCK FIRST-TEST-BLOCK DO
            I BUFFER DROP
        LOOP
    ;
    T{ BUFFER-ALL -> }T

    \ BUFFER twice on the same block returns the same value
    T{ RND-TEST-BLOCK DUP BUFFER SWAP BUFFER = -> TRUE }T

    \ BUFFER twice on distinct block numbers
    \ may or may not return the same value!
    \ Nothing to test

    \ Combinations with BUFFER
    T{ RND-TEST-BLOCK DUP BLOCK SWAP BUFFER = -> TRUE }T
    T{ RND-TEST-BLOCK DUP BUFFER SWAP BLOCK = -> TRUE }T
[THEN]

\ ------------------------------------------------------------------------------
TESTING Utilities

: C@++ ( c-addr -- c-addr;char+ c-addr@ )
    DUP CHAR+ SWAP C@ ;

\ I'm not sure if this algorithm is correct if " 1 CHARS 1 <> ".
: ELF-HASH-ACCUMULATE ( hash c-addr u -- hash )
    >R SWAP R> 0 DO                                \ c-addr h
        4 LSHIFT                                   \ c-addr h<<=4
        SWAP C@++ ROT +                            \ c-addr' h+=*s
        DUP [ BASE @ HEX ] F0000000 [ BASE ! ] AND \ c-addr' h high=h&0xF0000000
        DUP IF                                     \ c-addr' h high
            DUP >R 24 RSHIFT XOR R>                \ c-addr' h^=high>>24 high
        THEN                                       \ c-addr' h high
        INVERT AND                                 \ c-addr' h&=~high
    LOOP NIP ;

: ELF-HASH ( c-addr u -- hash )
    2>R 0 2R> ELF-HASH-ACCUMULATE ;

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    TEST-BLOCK-COUNT 10 LSHIFT CHARS CONSTANT (BLOCK-STORE-SIZE)
    (BLOCK-STORE-SIZE) UNUSED 10240 - U< [IF]
        CREATE (BLOCK-STORE) (BLOCK-STORE-SIZE) ALLOT

        : SAVE-TEST-BLOCKS ( -- )
            (BLOCK-STORE) LIMIT-TEST-BLOCK FIRST-TEST-BLOCK DO
                I BLOCK OVER 1024 CHARS MOVE
                1024 CHARS +
            LOOP DROP
        ;

        : RESTORE-TEST-BLOCKS ( -- )
            (BLOCK-STORE) LIMIT-TEST-BLOCK FIRST-TEST-BLOCK DO
                DUP I BLOCK 1024 CHARS MOVE
                UPDATE
                1024 CHARS +
            LOOP DROP
            FLUSH
        ;
    [ELSE]
        .( Warning: Designated Test Blocks will be scrambled ) CR
    [THEN]
[THEN]

[DEFINED] SAVE-TEST-BLOCKS [IF]
    SAVE-TEST-BLOCKS
[THEN]

\ ------------------------------------------------------------------------------
TESTING Read and Write access with UPDATE and FLUSH

\ Ideally, we'd like to be able to test the persistence across power cycles
\ of the writes, but we can't do that in a simple test.
\ The tests below could be fooled by a large buffers store and a tricky FLUSH
\ but what else are you going to do?

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    \ Signatures
    T{ RND-TEST-BLOCK BLOCK DROP UPDATE -> }T
    T{ FLUSH -> }T

    : BLANK-BUFFER ( blk -- blk-addr )
        BUFFER DUP 1024 BL FILL ;

    \ Test R/W of a Simple Blank Random Block
    T{ RND-TEST-BLOCK                 \ blk
       DUP BLANK-BUFFER               \ blk blk-addr1
       1024 ELF-HASH                  \ blk hash
       UPDATE FLUSH                   \ blk hash
       SWAP BLOCK                     \ hash blk-addr2
       1024 ELF-HASH = -> TRUE }T

    \ Boundary Test: Modify first character
    T{ RND-TEST-BLOCK                  \ blk
       DUP BLANK-BUFFER CHAR \ OVER C! \ blk blk-addr1
       1024 ELF-HASH                   \ blk hash
       UPDATE FLUSH                    \ blk hash
       SWAP BLOCK                      \ hash blk-addr2
       1024 ELF-HASH = -> TRUE }T

    \ Boundary Test: Modify last character
    T{ RND-TEST-BLOCK                               \ blk
       DUP BLANK-BUFFER CHAR \ OVER 1023 CHARS + C! \ blk blk-addr1
       1024 ELF-HASH                                \ blk hash
       UPDATE FLUSH                                 \ blk hash
       SWAP BLOCK                                   \ hash blk-addr2
       1024 ELF-HASH = -> TRUE }T

    \ Boundary Test: First and Last (and all other) blocks in the test range
    1024 1 CELLS / CONSTANT CELLS-PER-BLOCK

    : PREPARE-RND-BLOCK ( hash blk -- hash' )
        BUFFER DUP                      \ hash blk-addr blk-addr
        CELLS-PER-BLOCK 0 DO            \ hash blk-addr blk-addr[i]
            DUP BLOCK-RND SWAP ! CELL+  \ hash blk-addr blk-addr[i+1]
        LOOP DROP                       \ hash blk-addr
        1024 ELF-HASH-ACCUMULATE ;      \ hash'

    : WRITE-RND-BLOCKS-WITH-HASH ( blk2 blk1 -- hash )
        0 ROT ROT DO                                  \ hash
            I PREPARE-RND-BLOCK UPDATE                \ hash'
        LOOP ;                                        \ hash'

    : READ-BLOCKS-AND-HASH ( blk2 blk1 -- hash )
        0 ROT ROT DO                         \ hash(i)
            I BLOCK 1024 ELF-HASH-ACCUMULATE \ hash(i+1)
        LOOP ;                               \ hash

    T{ LIMIT-TEST-BLOCK FIRST-TEST-BLOCK WRITE-RND-BLOCKS-WITH-HASH FLUSH
       LIMIT-TEST-BLOCK FIRST-TEST-BLOCK READ-BLOCKS-AND-HASH = -> TRUE }T

    : TUF1 ( xt blk -- hash )
        DUP BLANK-BUFFER               \ xt blk blk-addr1
        1024 ELF-HASH                  \ xt blk hash
        ROT EXECUTE                    \ blk hash
        SWAP BLOCK                     \ hash blk-addr2
        1024 ELF-HASH = ;              \ TRUE

    \ Double UPDATE make no difference
    : TUF1-1 ( -- ) UPDATE UPDATE FLUSH ;
    T{ ' TUF1-1 RND-TEST-BLOCK TUF1 -> TRUE }T

    \ Double FLUSH make no difference
    : TUF1-2 ( -- ) UPDATE FLUSH FLUSH ;
    T{ ' TUF1-2 RND-TEST-BLOCK TUF1 -> TRUE }T

    \ FLUSH only saves UPDATEd buffers
    T{ RND-TEST-BLOCK                      \ blk
       0 OVER PREPARE-RND-BLOCK            \ blk hash
       UPDATE FLUSH                        \ blk hash
       OVER 0 SWAP PREPARE-RND-BLOCK DROP  \ blk hash
       FLUSH ( with no preliminary UPDATE) \ blk hash
       SWAP BLOCK 1024 ELF-HASH = -> TRUE }T

    2 TEST-BLOCK-COUNT U< [IF]
        \ UPDATE only marks the current block buffer
        : TUF2 ( xt blk1 blk2 -- hash1'' hash2'' hash1' hash2' hash1 hash2 )
            OVER BUFFER OVER BUFFER = IF \ test needs 2 distinct buffers
                2DROP DROP 0 0 0 0 0 0 \ Dummy result
            ELSE
                OVER 0 SWAP PREPARE-RND-BLOCK UPDATE \ xt blk1 blk2 hash1
                OVER 0 SWAP PREPARE-RND-BLOCK UPDATE \ xt blk1 blk2 hash1 hash2
                2>R                                  \ xt blk1 blk2
                FLUSH                                \ xt blk1 blk2
                OVER 0 SWAP PREPARE-RND-BLOCK        \ xt blk1 blk2 hash1'
                OVER 0 SWAP PREPARE-RND-BLOCK       \ xt blk1 blk2 hash1' hash2'
                2>R                                  \ xt blk1 blk2
                ROT EXECUTE                          \ blk1 blk2
                FLUSH                                \ blk1 blk2
                SWAP BLOCK 1024 ELF-HASH             \ blk2 hash1''
                SWAP BLOCK 1024 ELF-HASH             \ hash1'' hash2''
                2R> 2R> \ hash1'' hash2'' hash1' hash2' hash1 hash2
            THEN ;

        : 2= ( x1 x2 x3 x4 -- flag )
            ROT = ROT ROT = AND ;

        : TUF2-0 ( blk1 blk2 -- blk1 blk2 ) ;   \ no updates
        T{ ' TUF2-0 2RND-TEST-BLOCKS TUF2       \ run test procedure
           2SWAP 2DROP 2= -> TRUE }T            \ compare expected and actual

        : TUF2-1 ( blk1 blk2 -- blk1 blk2 )     \ update blk1 only
            OVER BLOCK DROP UPDATE ;
        T{ ' TUF2-1 2RND-TEST-BLOCKS TUF2       \ run test procedure
           SWAP DROP SWAP DROP 2= -> TRUE }T

        : TUF2-2 ( blk1 blk2 -- blk1 blk2 )     \ update blk2 only
            DUP BUFFER DROP UPDATE ;
        T{ ' TUF2-2 2RND-TEST-BLOCKS TUF2       \ run test procedure
           DROP ROT DROP SWAP 2= -> TRUE }T

        : TUF2-3 ( blk1 blk2 -- blk1 blk2 )     \ update blk1 and blk2
            TUF2-1 TUF2-2 ;
        T{ ' TUF2-3 2RND-TEST-BLOCKS TUF2       \ run test procedure
           2DROP 2= -> TRUE }T
    [THEN]

    \ FLUSH and then UPDATE is ambiguous and untestable
[THEN]

\ ------------------------------------------------------------------------------
TESTING SAVE-BUFFERS

\ In principle, all the tests above can be repeated with SAVE-BUFFERS instead of
\ FLUSH.  However, only the full random test is repeated...

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]

    T{ LIMIT-TEST-BLOCK FIRST-TEST-BLOCK WRITE-RND-BLOCKS-WITH-HASH SAVE-BUFFERS
       LIMIT-TEST-BLOCK FIRST-TEST-BLOCK READ-BLOCKS-AND-HASH = -> TRUE }T

    \ FLUSH and then SAVE-BUFFERS is harmless but undetectable
    \ SAVE-BUFFERS and then FLUSH is undetectable

    \ Unlike FLUSH, SAVE-BUFFERS then BUFFER/BLOCK
    \ returns the original buffer address
    T{ RND-TEST-BLOCK DUP BLANK-BUFFER
       SAVE-BUFFERS        SWAP BUFFER = -> TRUE }T
    T{ RND-TEST-BLOCK DUP BLANK-BUFFER
       UPDATE SAVE-BUFFERS SWAP BUFFER = -> TRUE }T
    T{ RND-TEST-BLOCK DUP BLANK-BUFFER
       SAVE-BUFFERS        SWAP BLOCK  = -> TRUE }T
    T{ RND-TEST-BLOCK DUP BLANK-BUFFER
       UPDATE SAVE-BUFFERS SWAP BLOCK  = -> TRUE }T
[THEN]

\ ------------------------------------------------------------------------------
TESTING BLK

\ Signature
T{ BLK DUP ALIGNED = -> TRUE }T

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    \ None of the words considered so far effect BLK
    T{ BLK @ RND-TEST-BLOCK BUFFER DROP BLK @ = -> TRUE }T
    T{ BLK @ RND-TEST-BLOCK BLOCK  DROP BLK @ = -> TRUE }T
    T{ BLK @ UPDATE                     BLK @ = -> TRUE }T
[THEN]
T{ BLK @ FLUSH        BLK @ = -> TRUE }T
T{ BLK @ SAVE-BUFFERS BLK @ = -> TRUE }T

\ ------------------------------------------------------------------------------
TESTING LOAD and EVALUATE

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    \ Signature: n LOAD --> blank screen
    T{ RND-TEST-BLOCK DUP BLANK-BUFFER DROP UPDATE FLUSH LOAD -> }T

    : WRITE-BLOCK ( blk c-addr u -- )
        ROT BLANK-BUFFER SWAP CHARS MOVE UPDATE FLUSH ;

    \ blk LOAD --> n
    : TL1 ( n blk -- )
        SWAP 0 <# #S #> WRITE-BLOCK ;
    T{ BLOCK-RND RND-TEST-BLOCK 2DUP TL1 LOAD = -> TRUE }T

    \ Boundary Test: FIRST-TEST-BLOCK
    T{ BLOCK-RND FIRST-TEST-BLOCK 2DUP TL1 LOAD = -> TRUE }T

    \ Boundary Test: LIMIT-TEST-BLOCK-1
    T{ BLOCK-RND LIMIT-TEST-BLOCK 1- 2DUP TL1 LOAD = -> TRUE }T

    : WRITE-AT-END-OF-BLOCK ( blk c-addr u -- )
        ROT BLANK-BUFFER
        OVER 1024 SWAP - CHARS +
        SWAP CHARS MOVE UPDATE FLUSH ;

    \ Boundary Test: End of Buffer
    : TL2 ( n blk -- )
        SWAP 0 <# #S #> WRITE-AT-END-OF-BLOCK ;
    T{ BLOCK-RND RND-TEST-BLOCK 2DUP TL2 LOAD = -> TRUE }T

    \ LOAD updates BLK
    \ n: "BLK @"; n LOAD
    : TL3 ( blk -- )
        S" BLK @" WRITE-BLOCK ;
    T{ RND-TEST-BLOCK DUP TL3 DUP LOAD = -> TRUE }T

    \ EVALUATE resets BLK
    \ n: "EVALUATE-BLK@"; n LOAD
    : EVALUATE-BLK@ ( -- BLK@ )
        S" BLK @" EVALUATE ;
    : TL4 ( blk -- )
        S" EVALUATE-BLK@" WRITE-BLOCK ;
    T{ RND-TEST-BLOCK DUP TL4 LOAD -> 0 }T

    \ EVALUTE can nest with LOAD
    \ n: "BLK @"; S" n LOAD" EVALUATE
    : TL5 ( blk -- c-addr u )
        0 <#                       \ blk 0
            [CHAR] D HOLD
            [CHAR] A HOLD
            [CHAR] O HOLD
            [CHAR] L HOLD
                   BL HOLD
        #S #> ;                    \ c-addr u
    T{ RND-TEST-BLOCK DUP TL3 DUP TL5 EVALUATE = -> TRUE }T

    2 TEST-BLOCK-COUNT U< [IF]
        \ Nested LOADs
        \ n2: "BLK @"; n1: "LOAD n2"; n1 LOAD
        : TL6 ( blk1 blk2 -- )
            DUP TL3                    \ blk1 blk2
            TL5 WRITE-BLOCK ;
        T{ 2RND-TEST-BLOCKS 2DUP TL6 SWAP LOAD = -> TRUE }T

        \ LOAD changes the currect block that is effected by UPDATE
        : TL7 ( blk1 blk2 -- u1 u2 rnd2 blk2-addr rnd1' rnd1 )
            OVER BUFFER OVER BUFFER = IF \ test needs 2 distinct buffers
                2DROP 0 0 0 0 0 0 \ Dummy result
            ELSE
                OVER BLOCK-RND DUP ROT TL1 >R   \ blk1 blk2
                DUP S" SOURCE DROP" WRITE-BLOCK \ blk1 blk2
                \ change blk1 to a new rnd, but don't UPDATE
                OVER BLANK-BUFFER               \ blk1 blk2 blk1-addr
                BLOCK-RND DUP >R                \ blk1 blk2 blk1-addr rnd1'
                0 <# #S #>                      \ blk1 blk2 blk1-addr c-addr u
                ROT SWAP CHARS MOVE             \ blk1 blk2
                \ Now LOAD blk2
                DUP LOAD DUP >R                 \ blk1 blk2 blk2-addr
                \ Write a new blk2
                DUP 1024 BL FILL                \ blk1 blk2 blk2-addr
                BLOCK-RND DUP >R                \ blk1 blk2 blk2-addr rnd2
                0 <# #S #>                      \ blk1 blk2 blk2-addr c-addr u
                ROT SWAP CHARS MOVE             \ blk1 blk2
                \ The following UPDATE should refer to the LOADed blk2, not blk1
                UPDATE FLUSH                    \ blk1 blk2
                \ Finally, load both blocks then collect all results
                LOAD SWAP LOAD                  \ u2 u1
                R> R> R> R>                     \ u2 u1 rnd2 blk2-addr rnd1' rnd1
                DECIMAL
            THEN ;
        T{ 2RND-TEST-BLOCKS TL7                 \ run test procedure
           SWAP DROP SWAP DROP                  \ u2 u1 rnd2 rnd1
           2= -> TRUE }T

    [THEN]

    \ I would expect LOAD to work on the contents of the buffer cache
    \ and not the block device, but the specification doesn't say.
    \ Similarly, I would not expect LOAD to FLUSH the buffer cache,
    \ but the specification doesn't say so.

[THEN]

\ ------------------------------------------------------------------------------
TESTING LIST and SCR

\ Signatures
T{ SCR DUP ALIGNED = -> TRUE }T
\ LIST signature is test implicitly in the following tests...

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    : TLS1 ( blk -- )
        S" Should show a (mostly) blank screen" WRITE-BLOCK ;
    T{ RND-TEST-BLOCK DUP TLS1 DUP LIST SCR @ = -> TRUE }T

    \ Boundary Test: FIRST-TEST-BLOCK
    : TLS2 ( blk -- )
        S" List of the First test block" WRITE-BLOCK ;
    T{ FIRST-TEST-BLOCK DUP TLS2 LIST -> }T

    \ Boundary Test: LIMIT-TEST-BLOCK
    : TLS3 ( blk -- )
        S" List of the Last test block" WRITE-BLOCK ;
    T{ LIMIT-TEST-BLOCK 1- DUP TLS3 LIST -> }T

    \ Boundary Test: End of Screen
    : TLS4 ( blk -- )
        S" End of Screen" WRITE-AT-END-OF-BLOCK ;
    T{ RND-TEST-BLOCK DUP TLS4 LIST -> }T

    \ BLOCK, BUFFER, UPDATE et al don't change SCR
    2 TEST-BLOCK-COUNT U< [IF]
        : TLS5 ( blk -- )
            S" Should show another (mostly) blank screen" WRITE-BLOCK ;
        \ the first test below sets the scenario for the subsequent tests
        \ BLK is unchanged by LIST
        T{ BLK @ 2 RND-TEST-BLOCK-SEQ DUP TLS5 LIST          BLK @ = -> TRUE }T
        \ SCR is unchanged by Earlier words
        T{ SCR @ FLUSH                                       SCR @ = -> TRUE }T
        T{ SCR @ FLUSH DUP 1+ BUFFER DROP                    SCR @ = -> TRUE }T
        T{ SCR @ FLUSH DUP 1+ BLOCK DROP                     SCR @ = -> TRUE }T
        T{ SCR @ FLUSH DUP 1+ BLOCK DROP UPDATE              SCR @ = -> TRUE }T
        T{ SCR @ FLUSH DUP 1+ BLOCK DROP UPDATE SAVE-BUFFERS SCR @ = -> TRUE }T
        : TLS6 ( blk -- )
            S" SCR @" WRITE-BLOCK ;
        T{ SCR @ RND-TEST-BLOCK DUP TLS6 LOAD          SCR @ OVER 2= -> TRUE }T
    [THEN]
[THEN]

\ ------------------------------------------------------------------------------
TESTING EMPTY-BUFFERS

T{ EMPTY-BUFFERS -> }T
T{ BLK @ EMPTY-BUFFERS BLK @ = -> TRUE }T
T{ SCR @ EMPTY-BUFFERS SCR @ = -> TRUE }T

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    \ Test R/W, but discarded changes with EMPTY-BUFFERS
    T{ RND-TEST-BLOCK                    \ blk
       DUP BLANK-BUFFER                  \ blk blk-addr1
       1024 ELF-HASH                     \ blk hash
       UPDATE FLUSH                      \ blk hash
       OVER BLOCK CHAR \ SWAP C!         \ blk hash
       UPDATE EMPTY-BUFFERS FLUSH        \ blk hash
       SWAP BLOCK                        \ hash blk-addr2
       1024 ELF-HASH = -> TRUE }T

    2 TEST-BLOCK-COUNT U< [IF]
        \ EMPTY-BUFFERS discards all buffers
        : TUF2-EB ( blk1 blk2 -- blk1 blk2 )
            TUF2-1 TUF2-2 EMPTY-BUFFERS ;  \ c.f. TUF2-3
        T{ ' TUF2-EB 2RND-TEST-BLOCKS TUF2
           2SWAP 2DROP 2= -> TRUE }T
    [THEN]

    \ FLUSH and then EMPTY-BUFFERS is acceptable but untestable
    \ EMPTY-BUFFERS and then UPDATE is ambiguous and untestable
[THEN]

\ ------------------------------------------------------------------------------
TESTING \

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    : 2WRITE-BLOCK ( c-addr1 u1 c-addr2 u2 blk -- )
        BLANK-BUFFER                    \ c-addr1 u1 c-addr2 u2 a-addr
        >R 2SWAP R@ SWAP CHARS MOVE R>  \ c-addr2 u2 addr
        512 CHARS + SWAP CHARS MOVE     \
        UPDATE FLUSH ;

    \ Discards to the end of the line
    : TC1 ( blk -- )
        >R S" 2222 \ 3333 " S" 4444" R> 2WRITE-BLOCK ;
    T{ RND-TEST-BLOCK DUP TC1 LOAD -> 2222 4444 }T
[THEN]

\ ------------------------------------------------------------------------------
TESTING THRU

FIRST-TEST-BLOCK LIMIT-TEST-BLOCK U< [IF]
    2 TEST-BLOCK-COUNT U< [IF]
        : TT1 ( blk -- )
            DUP S" BLK" WRITE-BLOCK
            1+ S" @" WRITE-BLOCK ;
        T{ 2 RND-TEST-BLOCK-SEQ DUP TT1 DUP DUP 1+ THRU 1- = -> TRUE }T
    [THEN]
[THEN]

\ ------------------------------------------------------------------------------
[DEFINED] RESTORE-TEST-BLOCKS [IF] RESTORE-TEST-BLOCKS [THEN]

[DEFINED] BLOCK-TEST-DICTIONARY [IF] BLOCK-TEST-DICTIONARY [THEN]

BLOCK-ERRORS SET-ERROR-COUNT

CR .( End of Block word tests) CR
